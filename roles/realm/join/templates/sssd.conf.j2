[sssd]

config_file_version = 2
reconnection_retries = 3
sbus_timeout = 30
services = nss, pam
domains = {{ ad_domain }}
 
[nss]

# Our best practice is that the service users have to be local users and the 
# non-service users are in LDAP-compliant identity/directory services, such as 
# OpenLDAP or Microsoft Active Directory

filter_groups = root,mysql,hadoop,yarn,hdfs,mapred,kms,httpfs,hbase,hive,sentry,spark,solr,sqoop,oozie,hue,flume,impala,llama,postgres,sqoop2,kudu,kafka,accumulo,zookeeper,cloudera-scm,keytrustee
filter_users = root,mysql,cloudera-scm,zookeeper,yarn,hdfs,mapred,kms,httpfs,hbase,hive,sentry,spark,solr,sqoop,oozie,hue,flume,impala,llama,sqoop2,postgres,kudu,kafka,accumulo,keytrustee
reconnection_retries = 3
 
# entry_cache_timeout = 3600
# entry_negative_timeout = 30
# entry_cache_nowait_percentage = 7

[pam]

reconnection_retries = 3
 
[domain/{{ ad_domain }}]

debug_level = 3
ad_enable_gc = false
cache_credentials = true
ldap_id_mapping = true

# The override_gid will be the primary group of all domain users. 
# This gid must be changed later to a valid one that all users belong to

# override_gid = 574066993

# A new option auto_private_groups was added in SSSD 1.16.1. If this option 
# is enabled, SSSD will automatically create user private groups based on userâ€™s 
# UID number. The GID number is ignored in this case. 

# auto_private_groups = true
 
full_name_format = %1$s
fallback_homedir = /home/%u
default_shell = /bin/bash
ignore_group_members = true
krb5_realm = {{ krb5_realm }}
ad_domain = {{ ad_domain }}
id_provider = ad
chpass_provider = ad
auth_provider = ad

# Setting this ad_access_filter limit access to ONLY that group being 
# allowed to log in, use with caution 
access_provider = ad
# ad_access_filter = (|(memberOf=memberOf=CN=hadoop_admins,OU=groups,OU=hadoop_prd,DC=ad,DC=sec,DC=example,DC=com)(memberOf=CN=hadoop_users,OU=groups,OU=hadoop_prd,DC=ad,DC=sec,DC=example,DC=com))

# To override the site autodiscovery, specify the AD site to which you want the 
# client to connect by using the ad_site option

# ad_site = Default-First-Site-Name

case_sensitive = false
enumerate = false
ldap_schema = ad
ldap_user_principal = nosuchattr
ldap_force_upper_case_realm = true
ldap_purge_cache_timeout = 0
ldap_account_expire_policy = ad

# subdomains_provider = none can help to resolve significant delays in case of multiple AD domains
# There is a known issue by Red Hat Enterprise Linux 6, further information about this : https://bugzilla.redhat.com/show_bug.cgi?id=1221358
# subdomains_provider = none

# If you know that your users and groups will be limited to a specific subsection of the directory, you can limit lookups using the ldap_group_search_base and ldap_user_search_base parameters. This can give significant speedups for large directories.

ldap_group_search_base = {{ ldap_group_search_base }}
ldap_user_search_base = {{ ldap_user_search_base }}

# Uncomment the following if deploying on Azure, which has no reverse DNS or in any environment which has DNS managed by AD.

# dyndns_update = true
# dyndns_refresh_interval = 43200
# dyndns_update_ptr = true
# dyndns_ttl = 3600

ldap_use_tokengroups = false

# krb5_validate = false will prevent unnecessary pac processing and validating if the tgt can get a service ticket for the logged in host

krb5_validate = false

# In environments with large number of users and groups you'll also need to set the idmap range 

# ldap_idmap_range_size = 2000000

